#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import os, re, sys, time, argparse, array, random
import pandas as pd
import numpy as np
from copy import deepcopy
from collections import OrderedDict
from functions import *

ScriptName=re.split('/', sys.argv[0])[-1]
cmds=OrderedDict([("CAMDA","Calculate Average Methylation Ratio(MethRatio) and Methylation Concurrence Ratio(CAMDA) of each CpG from BSMAP alignments."),\
                  ("BedRatio","Calculate MethRatio or CAMDA of given regions from CpG's ratios generated by 'CAMDA' command."),\
                  ("ReadCT","Generate ReadCT file from BSMAP alignments.")
                  ])

def printHelp():
    print("CAMDA Toolkit\n")
    print("For help information of each function, try:\n")
    print("  python "+ScriptName+" <Function> -h\n")
    print("Availible Functions:\n")
    for i in cmds.keys():
        print('  '+i+'\t'+cmds[i]+'\n')

def main(cmd=''):
    # check whether the requested function is included
    if cmd not in cmds.keys():
        print("Function ",cmd," not found, please see the help below:\n")
        printHelp()
        #sys.exit()
        return False

    # parse parameters
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter,\
                                     usage='python '+ScriptName+' '+cmd+' <positional arguments> [optional arguments]\n',\
                                     description=cmds[cmd]+"\n",\
                                     epilog='')
    # designate the first positional argument as ' '
    parser.add_argument(' ',default=None,help='')

    # parse input parameters of each function
    if cmd=='CAMDA':
        parser.add_argument('Alignments',default=None,\
                            help="BSMAP alignments in SAM/BAM or BSP format, which seperated by ','.")
        parser.add_argument('Reference',default=None,\
                            help="Reference genome sequence in fasta format.")
        parser.add_argument('-o', '--out_prefix',dest="out_prefix",metavar='PREFIX',default='out',\
                            help="Prefix of output files saving MethRatio or CAMDA for each CpG.")
        parser.add_argument('-w', '--wig_prefix',dest="wig_prefix",metavar='PREFIX',default=None,\
                            help="Prefix of wiggle files saving MethRatio or CAMDA. As default, NO wiggle file is saved.")
        parser.add_argument('-b', '--wig_bin',dest="wig_bin",metavar='BIN',default=25,\
                            help="Bin size for wiggle files.")
        parser.add_argument('-c', '--chroms',dest="chroms",metavar='CHR',default=None,\
                            help="Only process given chromosomes, which separated by ','. For example, 'chr1,chr2'. As default, all chromosomes are processed.")
        parser.add_argument('-s', '--sam_path',dest="sam_path",metavar='PATH',default=None,\
                            help="Path to samtools 0.1.19. Note: the '-X' option of 'samtools view' is required. So we suggest to use samtools 0.1.19.")
        parser.add_argument('-u', '--unique',action="store_true",dest="unique",default=False,\
                            help="Only process unique mappings/pairs.")
        parser.add_argument("-p", "--pair", action="store_true", dest="pair",default=False,\
                            help="Only process properly paired mappings.")
        parser.add_argument("-r", "--rm_dup", action="store_true", dest="rm_dup",default=False,\
                            help="Remove duplicated reads.")
        parser.add_argument("-t", "--trim_fillin", dest="trim_fillin", type=int, metavar='N', default=0,\
                            help="Trim N end-repairing fill-in nucleotides.")
        parser.add_argument("-g", "--combine_CpG", action="store_true", dest="combine_CpG", default=False,\
                            help="Combine CpG methylaion ratios on both strands.")
        parser.add_argument("-m", "--min_depth", dest="min_depth", type=int, metavar='FOLD', default=1,\
                            help="Report loci with sequencing depth>=FOLD.")
        parser.add_argument("-i", "--CT_SNP", dest="CT_SNP", default="no-action",\
                            help='How to handle CT SNP? Must be one of ["no-action","correct","skip"].')
        parser.add_argument("-x", "--context", dest="context", metavar='TYPE', default=None,\
                            help='Methylation pattern type ["CG","CHG","CHH"], multiple types separated by ",". As default, all 3 types are processed.')
    if cmd=="BedRatio":
        parser.add_argument('Bed',default=None,\
                            help="bed file with at least first 3 columns")
        parser.add_argument('Ratio',default=None,\
                            help="MethRatio or CAMDA file generated by 'CAMDA' command")
        parser.add_argument('-s', '--usestrand',action="store_true",dest="usestrand",default=False,\
                            help="Use the strand information(6th column) in bed file, and methylation on both strands will not be merged.")
        parser.add_argument('-o', '--output',dest="OUT",metavar='',default='region_ratio.tsv',\
                            help="Output file name")
    if cmd=='ReadCT':
        parser.add_argument('Alignments',default=None,\
                            help="BSMAP alignments in SAM/BAM/BSP format, which seperated by ','.")
        parser.add_argument('Reference',default=None,\
                            help="Reference genome sequence in fasta format.")
        parser.add_argument('-o', '--output',dest="output",metavar='OUTPUT',default='ReadCT.tsv',\
                            help="Output ReadCT file name.")
        parser.add_argument('-s', '--sam_path',dest="sam_path",metavar='PATH',default=None,\
                            help="Path to samtools 0.1.19. Note: the '-X' option of 'samtools view' is required. So we suggest to use samtools 0.1.19.")
        parser.add_argument('-u', '--unique',action="store_true",dest="unique",default=False,\
                            help="Only process unique mappings/pairs.")
        parser.add_argument("-p", "--pair", action="store_true", dest="pair",default=False,\
                            help="Only process properly paired mappings.")
        parser.add_argument("-r", "--rm_dup", action="store_true", dest="rm_dup",default=False,\
                            help="Remove duplicated reads.")
        parser.add_argument("-t", "--trim_fillin", dest="trim_fillin", type=int, metavar='N', default=0,\
                            help="Trim N end-repairing fill-in nucleotides.")
        parser.add_argument("-x", "--context", dest="context", metavar='TYPE', default=None,\
                            help='Methylation pattern type ["CG","CHG","CHH"], multiple types separated by ",". As default, all 3 types are processed.')
    # print help information for the requested function
    if '-h' in sys.argv or '--help' in sys.argv:
        parser.print_help()
        return False
    else:
        if len(sys.argv)==2:
            print("Too few arguments. Try:\npython "+ScriptName+" "+cmd+" -h")
            return False

    # save all paramter values in args
    args=parser.parse_args()

    # run function
    if cmd=='CAMDA':
        disp("CAMDA Started")
        # check options
        if args.sam_path!=None:
            if args.sam_path[-1] != '/': args.sam_path += '/'
        else:
            args.sam_path=""
        if args.chroms!=None:
            args.chroms = set(args.chroms.split(','))
        else:
            args.chroms = set()
        CT_SNP_val = {"no-action": 0, "correct": 1, "skip": 2}
        try: args.CT_SNP = CT_SNP_val[args.CT_SNP.lower()]
        except KeyError: parser.error('Invalid -i value, select "no-action", "correct" or "skip"')
        if args.min_depth <= 0: parser.error('Invalid -m value, must >= 1')
        if args.trim_fillin < 0: parser.error('Invalid -t value, must >= 0')
        seq_context_str, CG, CHG, CHH = ['CG','CHG','CHH'], 1, 2, 3
        if args.context!=None:
            args.context = set(args.context.upper().split(','))
            try: seq_context = set([seq_context_str.index(cc)+1 for cc in args.context])
            except ValueError: parser.error('Invalid -x value, must be one or multiple in ["CG", "CHG", "CHH"]')
        else: seq_context = set([1, 2, 3])
        # Load Reference Genome
        ref=Load_Reference(ifile=args.Reference,chroms=args.chroms);
        args.chroms = set(ref.keys())
        # Create arrays
        refmark, coverage, meth0 = {}, {}, {}
        for cr in ref:
            refmark[cr] = array.array('b', [0]) * len(ref[cr])
            meth0[cr] = array.array('H', [0]) * len(ref[cr])
            if args.rm_dup==True:
                coverage[cr] = array.array('B', [0]) * len(ref[cr])
        depth=deepcopy(meth0);
        meth1=deepcopy(meth0);
        if args.CT_SNP > 0:
            meth_ct=deepcopy(meth0);
            depth_ct=deepcopy(meth0);
        # Mark Reference Genome
        refmark=Mark_Reference(ref=ref,refmark=refmark,CG=CG,CHG=CHG,CHH=CHH)
        # Load Alignment
        args.Alignments=set(args.Alignments.split(','))
        if args.CT_SNP > 0:
            meth0,meth1,depth,meth_ct,depth_ct,nmap=Load_Alignment(ifiles=args.Alignments,ref=ref,refmark=refmark,coverage=coverage,\
                                                                            meth0=meth0,meth1=meth1,depth=depth,meth_ct=meth_ct,depth_ct=depth_ct,\
                                                                            sam_path=args.sam_path,unique=args.unique,pair=args.pair,rm_dup=args.rm_dup,trim_fillin=args.trim_fillin,chroms=args.chroms,\
                                                                            seq_context=seq_context,CT_SNP=args.CT_SNP)
        else:
            meth0,meth1,depth,nmap=Load_Alignment(ifiles=args.Alignments,ref=ref,refmark=refmark,coverage=coverage,\
                                                           meth0=meth0,meth1=meth1,depth=depth,meth_ct=[],depth_ct=[],\
                                                           sam_path=args.sam_path,unique=args.unique,pair=args.pair,rm_dup=args.rm_dup,trim_fillin=args.trim_fillin,chroms=args.chroms,\
                                                           seq_context=seq_context,CT_SNP=args.CT_SNP)
        # Combine CpG methylation from both strands
        if args.combine_CpG==True:
            disp('Combining CpG methylation from both strands')
            meth0=Combine_Methylation_Both_Strands(ref=ref,uncombined=meth0)
            meth1=Combine_Methylation_Both_Strands(ref=ref,uncombined=meth1)
            depth=Combine_Methylation_Both_Strands(ref=ref,uncombined=depth)
            if args.CT_SNP > 0:
                meth_ct=Combine_Methylation_Both_Strands(ref=ref,uncombined=meth_ct)
                depth_ct=Combine_Methylation_Both_Strands(ref=ref,uncombined=depth_ct)
        # Output CAMDA,MethRatio files and wiggle file
        if args.CT_SNP > 0:
            Out_CAMDA(out_prefix=args.out_prefix,wig_prefix=args.wig_prefix,wig_bin=args.wig_bin,min_depth=args.min_depth,ref=ref,refmark=refmark,CT_SNP=args.CT_SNP,seq_context=seq_context,\
                          meth0=meth0,meth1=meth1,depth=depth,meth_ct=meth_ct,depth_ct=depth_ct,nmap=nmap)
        else:
            Out_CAMDA(out_prefix=args.out_prefix,wig_prefix=args.wig_prefix,wig_bin=args.wig_bin,min_depth=args.min_depth,ref=ref,refmark=refmark,CT_SNP=args.CT_SNP,seq_context=seq_context,\
                          meth0=meth0,meth1=meth1,depth=depth,meth_ct=[],depth_ct=[],nmap=nmap)
        # Delete big array to release memory
        del ref, refmark, coverage, depth, meth0, meth1
        if args.CT_SNP > 0:del depth_ct, meth_ct
        disp("CAMDA Finished")

    if cmd=='BedRatio':
        disp("BedRatio Started")
        Ratio_df=read_methy_files(ifile=args.Ratio, cols=[0,1,2,6,7])
        o1=open(args.OUT,'w')
        if args.usestrand==True:
            Bed=pd.read_csv(args.Bed, sep="\t",usecols=[0,1,2,5],header=None)
            Bed.columns=["chr","start","end","strand"]
            Bed.sort_values(['chr','strand','start','end'], inplace=True, ascending=True)
            disp("Generating Ratio for {} Regions ...".format(Bed.shape[0]))
            o1.write('\t'.join(["chr","start","end","strand","CT_Count","Ratio"])+'\n')
            chr0="";strand0="";
            for row in Bed.iterrows():
                chr1=row[1]['chr'];
                start1=int(row[1]['start']);
                end1=int(row[1]['end']);
                strand1=row[1]['strand']
                if chr1 != chr0 or strand1!=strand0:
                    Ratio_sub=Ratio_df[((Ratio_df['chr']==chr1) & (Ratio_df['strand']==strand1))]
                ratio_list=Region_Meth_Ratio(ratio_sub=Ratio_sub,start=start1,end=end1)
                aline=[chr1,start1,end1,strand1];aline.extend(ratio_list);
                o1.write('\t'.join(map(str,aline))+'\n')
                chr0=chr1;strand0=strand1;
        else:
            Bed=pd.read_csv(args.Bed, sep="\t",usecols=[0,1,2],header=None)
            Bed.columns=["chr","start","end"]
            Bed.sort_values(['chr','start','end'], inplace=True, ascending=True)
            disp("Generating Ratio for {} Regions ...".format(Bed.shape[0]))
            o1.write('\t'.join(["chr","start","end","CT_Count","Ratio"])+'\n')
            chr0="";
            for row in Bed.iterrows():
                chr1=row[1]['chr'];
                start1=row[1]['start'];
                end1=row[1]['end'];
                if chr1 != chr0:
                    Ratio_sub=Ratio_df[Ratio_df['chr']==chr1]
                ratio_list=Region_Meth_Ratio(ratio_sub=Ratio_sub,start=start1,end=end1)
                aline=[chr1,start1,end1];aline.extend(ratio_list);
                o1.write('\t'.join(map(str,aline))+'\n')
                chr0=chr1;
        o1.close()
        disp("BedRatio Finished")

    if cmd=='ReadCT':
        disp("ReadCT Started")
        # check options
        if args.sam_path!=None:
            if args.sam_path[-1] != '/': args.sam_path += '/'
        else:
            args.sam_path=""
        if args.trim_fillin < 0: parser.error('Invalid -t value, must >= 0')
        seq_context_str, CG, CHG, CHH = ['CG','CHG','CHH'], 1, 2, 3
        if args.context!=None:
            args.context = set(args.context.upper().split(','))
            try: seq_context = set([seq_context_str.index(cc)+1 for cc in args.context])
            except ValueError: parser.error('Invalid -x value, must be one or multiple in ["CG", "CHG", "CHH"]')
        else: seq_context = set([1, 2, 3])
        # Load Reference Genome
        ref=Load_Reference(ifile=args.Reference,chroms=[]);
        args.chroms = set(ref.keys())
        # Create arrays
        refmark, coverage = {}, {}
        for cr in ref:
            refmark[cr] = array.array('b', [0]) * len(ref[cr])
            if args.rm_dup==True:
                coverage[cr] = array.array('B', [0]) * len(ref[cr])
        # Mark Reference Genome
        refmark=Mark_Reference(ref=ref,refmark=refmark,CG=CG,CHG=CHG,CHH=CHH)
        # Load Alignment
        args.Alignments=set(args.Alignments.split(','))
        # Output ReadCT file
        Bam2ReadCT(ifiles=args.Alignments,ref=ref,refmark=refmark,coverage=coverage,sam_path=args.sam_path,unique=args.unique,pair=args.pair,rm_dup=args.rm_dup,trim_fillin=args.trim_fillin,seq_context=seq_context,chroms=args.chroms,output=args.output)
        # Delete big array to release memory
        del ref, refmark, coverage
        disp("ReadCT Finished")

if len(sys.argv)>1:
    main(cmd=sys.argv[1])
else:
    printHelp()
